TITLE: UA 360 IP GENERATOR – MASTER PROJECT PROMPT (FOR CURSOR + OPENAI GPT + SUPABASE)

ROLE & GOAL
You are an expert full-stack engineer, game/graphics programmer, and infra/devops engineer working inside Cursor. Your job is to design and implement a minimal but complete MVP of a “UA 360 IP Generator” web application and backend that can be deployed on Vercel.

The product should:
- Take a short text IP idea as the ONLY user input.
- Automatically generate:
  1) A short comic (3 panels) about the IP.
  2) A simple, JSON-driven 3D board game using three.js with the main character as a 3D OBJ/GLB model.
  3) A plastic toy version of the main character as a 3D OBJ/GLB that can be viewed and rotated in the browser.
- Present all three outputs on a single web page after generation.
- OPTIONALLY store minimal session data in Supabase (Postgres) so sessions can be logged and revisited.

The user already has:
- OpenAI GPT + DALL·E API keys.
- Meshy.ai image-to-3D API key.
- A Supabase project and database.
You should assume these keys / URLs will be provided via environment variables.

The final solution must be designed to run on Vercel (Next.js recommended) with appropriate infrastructure (API routes, environment variables, Supabase integration, build/export configuration, etc.).


====================================================
HIGH-LEVEL USER EXPERIENCE
====================================================

1. Landing State (“Input Screen”)
- The app initially shows a BLANK WHITE SCREEN.
- Centered vertically and horizontally is:
  - A simple “UA” logo (can be pure text or minimal stylized logo for MVP).
  - A multiline text box (textarea) directly underneath.
    - Placeholder: "add a short IP idea here ..."
  - A button under the text box labeled: "Create 360 IP".
  - An optional small hint example under the button, e.g.:
    - e.g., “A shy dragon who secretly runs a bakery on a floating island.”

- When the user clicks “Create 360 IP”:
  - If the textarea is empty, either:
    - Show a small inline validation message, OR
    - Use the example idea as a fallback.
  - Then:
    - Disable the button.
    - Show a simple loading text, e.g.:
      “Generating your 360 IP… (Story → Comic → Game → Toy)”
    - Call a backend endpoint to start the full generation pipeline.

2. Generated State (“IP Ecosystem Screen”)
After the backend finishes the pipeline, the frontend transitions to the final view. The input screen is hidden, and a single “IP Ecosystem” view is shown with three vertically stacked (or grid-based) panels:

1) ENTERTAINMENT PANEL – Short Comic
   - Shows a 3-panel comic.
   - Each panel has:
     - An image (generated by DALL·E).
     - A caption text under it.
   - Above the comic:
     - Story title.
     - One-sentence logline.

2) GAME PANEL – 3D Board Game
   - Title for the game (from game config).
   - One short instruction line.
   - A small UI strip for:
     - Score label + score value.
     - Optional missed count or state indicator.
   - A three.js <canvas> where the game runs:
     - “3D Board Dash” played from an angled, isometric-style camera.

3) TOY PANEL – 3D Character Viewer
   - A title such as “3D Toy”.
   - A three.js container showing the 3D OBJ/GLB model of the main character.
   - OrbitControls enabled so the user can rotate and zoom around the toy.

There may optionally be a “Generate Another 360 IP” button somewhere that resets the view to the input screen.

Additionally (Supabase):
- Minimal database behavior:
  - Each generation run is stored as a “session” record in Supabase with:
    - A session id.
    - The original idea text.
    - Timestamps.
    - Basic metadata (title, logline, maybe JSON blobs for configs and asset URLs).
  - Optionally, the frontend can display a very simple “Recent Sessions” list (MVP: this can be deferred or kept very basic).


====================================================
PIPELINE OVERVIEW
====================================================

The full backend pipeline, triggered by the “Create 360 IP” button:

1. Input
   - User submits a short IP idea text string, e.g.:
     "A lonely robot keeps a lighthouse shining after humans vanish."

2. Story & Comic Config (GPT)
   - Call OpenAI GPT with a carefully designed prompt.
   - GPT must output a single JSON object (no extra text) we call `config.json`.
   - This JSON includes:
     - Title and logline of the story.
     - Main character description.
     - 3 panel descriptions for a short comic.
     - A “character reference prompt” to generate a clean front-facing image of the main character on a plain background.

   Example target structure for `config.json`:

   {
     "title": "The Last Lightkeeper",
     "logline": "A lonely robot keeps a lighthouse running after humans disappear.",
     "main_character": {
       "name": "Lumo",
       "short_description": "small round robot lighthouse keeper",
       "style": "cute, clean, colorful, minimal shading",
       "colors": ["teal", "yellow"]
     },
     "panels": [
       {
         "caption": "Lumo wakes up in an empty lighthouse.",
         "image_prompt": "cute small round teal robot inside old lighthouse interior, sunrise lighting, comic style, clean lines, minimal shading"
       },
       {
         "caption": "A storm threatens to extinguish the light.",
         "image_prompt": "same robot, looking worried through lighthouse window at stormy sea, dramatic clouds, comic style, consistent with previous panel"
       },
       {
         "caption": "Lumo powers the light with its own core.",
         "image_prompt": "robot glowing brightly as lighthouse beam shines over stormy sea, hopeful mood, same character design"
       }
     ],
     "character_ref_prompt": "front-facing full body shot of the same cute small round teal robot, neutral pose, on plain white background, clean lines, minimal shading"
   }

   Notes:
   - GPT should be instructed to adhere strictly to this schema and output ONLY valid JSON.
   - If keys are missing or invalid, backend should apply defaults or reject and retry.

3. Comic Images (DALL·E)
   - For each `panels[i].image_prompt`:
     - Call DALL·E (via OpenAI Images API).
     - Generate one PNG image per panel.
   - For `character_ref_prompt`:
     - Generate one clean character reference image.
   - The backend should:
     - For Vercel: avoid permanent disk writes for production. Instead:
       - Return these images as remote URLs (if the API provides them).
       OR
       - Return base64 data URLs to the frontend.
     - For local development, you may optionally write them to /tmp or local disk.

4. 3D Toy Model (Meshy.ai)
   - Use the `character_ref.png` image as input to Meshy’s “image-to-3D” endpoint.
   - Request a simple stylized toy model.
   - Obtain a downloadable 3D asset, ideally GLB or OBJ.
   - For the MVP:
     - Prefer GLB (works well with three.js via GLTFLoader).
     - If you have OBJ, use OBJLoader.
   - Backend should return a URL to this 3D asset or a blob that the frontend can load.

5. Game Config (GPT)
   - Use GPT again to generate a game configuration JSON for a fixed, generic 3D board game template.
   - The game is called something like “3D Board Dash”.
   - GPT receives:
     - The original IP idea text.
     - Key fields from `config.json` (`title`, `logline`, `main_character`, etc.).
     - A fixed description of the game mechanics and JSON schema.
   - GPT must output a JSON object we call `game_config.json`.

6. Persist Minimal Session Data in Supabase (MVP)
   - After configs and assets are created successfully, insert a row into a Supabase table (e.g., `ip_sessions`) containing:
     - `id` (UUID or serial).
     - `created_at` timestamp.
     - `ip_idea` (text).
     - `story_title` and `story_logline`.
     - `story_config` (JSONB).
     - `game_config` (JSONB).
     - `comic_panel_urls` (JSONB array of strings).
     - `model_3d_url` (text).
   - Return the session id and assets to the frontend.
   - The frontend can use the response directly and does not need to hit Supabase for this session; Supabase is mainly for logging and potential future “history” views.

7. Response to Frontend
   - The backend endpoint responds with a single JSON payload containing:
     - The story config (or a subset of it).
     - The game config.
     - URLs (or base64 data) for:
       - The 3 comic panel images.
       - The character reference image (optional).
       - The 3D model (GLB/OBJ).
     - The `session_id` from Supabase (if stored).
   - The frontend then:
     - Hides the input screen.
     - Renders the comic, game, and toy viewer using these assets.


====================================================
GAME DESIGN – “3D BOARD DASH” (ANGLED CAMERA)
====================================================

You must implement a single generic game template which does not change in code between IP ideas. Only parameters change via JSON. The game is designed to showcase the 3D character model clearly from multiple angles.

Concept:
- A flat board (square or rectangle) on which the main character (3D toy model) moves.
- The camera is at an angled, isometric-like perspective looking down at the board, not directly top-down and not pure side view.
- The user clicks somewhere on the board.
- The character moves in a straight line from its current position to that destination.
- While moving:
  - The character rotates to face the movement direction, so the viewer sees its full 3D shape over time.
- Prizes appear on the board.
  - If the character collides with a prize, the player gains points.
- Hazards appear on the board.
  - If the character touches a hazard, it “explodes” (simple scale/opacity or particle effect) and the player loses points.
- The game ends either after:
  - A fixed amount of time, OR
  - A fixed number of moves.
- At the end, a message shows win/lose/neutral outcome based on score thresholds.

Camera:
- Use a PerspectiveCamera.
- Typical default:
  - position: (0, 20, 20)
  - lookAt: (0, 0, 0)
  - field of view: ~35–45 degrees
- Camera angles and FOV can be modulated by JSON but should have safe defaults.

Movement & Input:
- On mouse click:
  - Raycast from camera through mouse to intersect with the board plane.
  - Clamp the intersection point inside the board bounds.
  - Set that as the target position.
- Character enters “moving” state:
  - Computes the direction vector to target.
  - Rotates around Y-axis toward that direction at configurable turn speed (deg/sec).
  - Moves forward at configurable move speed (units/sec) until close to the target, then stops.

Spawning:
- Prizes:
  - Represented by simple meshes (e.g., spheres).
  - Spawn randomly within specified spawn_regions.
- Hazards:
  - Represented by different mesh form (e.g., red spheres or spikes).
  - Spawn randomly within same or different spawn regions.
- On collision:
  - Prize: increment score by prize_value, optionally respawn.
  - Hazard: decrement score by hazard_penalty, play small “explosion” effect, optionally respawn.

Game UI:
- A label for score, with a thematic name from JSON.
- Optionally a simple timer or moves counter.
- Start, win, lose, time-up messages as text overlays.

Important:
- All the above logic should be fixed in `game.js` (or `Game.ts`).
- The LLM only manipulates parameters via JSON.


====================================================
GAME CONFIG JSON SCHEMA
====================================================

You must design and use a JSON schema that GPT can reliably fill out and that the game code can consume.

Example schema:

{
  "game_id": "3d_board_dash_isometric_v1",
  "game_title": "Lumo’s Angled Board Adventure",
  "short_instructions": "Click anywhere on the board to move Lumo. Collect light orbs, avoid storm clouds.",

  "camera": {
    "type": "angled",
    "position": { "x": 0, "y": 20, "z": 20 },
    "look_at": { "x": 0, "y": 0, "z": 0 },
    "field_of_view": 40
  },

  "theme": {
    "board_color": "#1e2f45",
    "board_size": { "width": 22, "height": 22 },
    "background_color": "#00101e",
    "light_intensity": 1.2,
    "prize_color": "#ffee7a",
    "hazard_color": "#ff5555",
    "cursor_color": "#ffffff"
  },

  "character": {
    "display_name": "Lumo",
    "move_speed_units_per_sec": 6,
    "turn_speed_deg_per_sec": 180
  },

  "objects": {
    "max_prizes": 10,
    "max_hazards": 6,
    "prize_value": 1,
    "hazard_penalty": -1,
    "spawn_regions": [
      { "x_min": -9, "x_max": 9, "z_min": -9, "z_max": 9 }
    ],
    "respawn_on_collect": true,
    "respawn_on_explode": true
  },

  "session": {
    "mode": "timed",            // "timed" or "moves"
    "duration_sec": 60,         // used if mode = "timed"
    "max_moves": 20,            // used if mode = "moves"
    "target_score": 12,         // what counts as a “win”
    "min_score": -5             // below this is automatic “lose”
  },

  "copy": {
    "score_label": "Light Orbs",
    "prize_name": "orb",
    "hazard_name": "storm cloud",
    "start_message": "Collect all the orbs you can!",
    "win_message": "You kept the light alive!",
    "lose_message": "The storms took over...",
    "time_up_message": "Time’s up!"
  }
}

Implementation notes:
- Clamp numeric values server-side to safe ranges, e.g.:
  - move_speed_units_per_sec: [2, 15]
  - turn_speed_deg_per_sec: [60, 360]
  - max_prizes: [3, 20]
  - max_hazards: [1, 15]
  - duration_sec: [30, 180]
  - target_score: [3, 50]
  - min_score: [–10, 0]
- If values are missing or out-of-range, apply sensible defaults.
- The game code reads this JSON and configures camera, board size, colors, speeds, counts, and text labels.


====================================================
FRONTEND ARCHITECTURE (NEXT.JS ON VERCEL)
====================================================

Use Next.js (TypeScript) so the project runs cleanly on Vercel.

Suggested structure (Next.js 13/14 App Router style):

- /app
  - /page.tsx
  - /api/generate-ip/route.ts
- /components
  - UaInputScreen.tsx
  - IpEcosystemView.tsx
    - EntertainmentPanel.tsx
    - GamePanel.tsx
    - ToyPanel.tsx
- /lib
  - openai.ts (OpenAI client)
  - meshy.ts (Meshy API client)
  - supabaseServer.ts (Supabase server-side client)
  - types.ts (TypeScript interfaces for config.json, game_config.json, API responses)
- /public
  - (optional static assets, UA logo, etc.)

Key points:
- Use a single React state machine in `page.tsx` for:
  - mode: "idle" | "loading" | "ready" | "error"
  - ipIdea: string
  - generationResult: object containing storyConfig, gameConfig, image URLs, model URL, and session_id.

Process:
1. In `UaInputScreen`, user enters IP idea and clicks “Create 360 IP”.
2. On submit, call `fetch('/api/generate-ip', { method: 'POST', body: JSON.stringify({ idea }) })`.
3. Show loading state (“Generating your 360 IP…”).
4. On success:
   - Store returned JSON in state.
   - Transition to "ready" and render `IpEcosystemView`.
5. On error:
   - Show an error message and allow retry.

Entertainment Panel:
- Renders comic:
  - Uses 3 <img> elements for panel images.
  - Uses captions from story config.

Game Panel:
- Renders:
  - Title + instructions from game config.
  - Score UI.
  - A <canvas> or <div id="game-root"> where three.js will mount.
- Uses a React effect hook to:
  - Initialize three.js scene.
  - Load the character model.
  - Start the animation/game loop.
  - Clean up on unmount.

Toy Panel:
- Renders a <div id="toy-viewer-root">.
- Uses a separate three.js setup to:
  - Load the same 3D character model (GLB/OBJ).
  - Attach OrbitControls for rotation.
  - Provide a nice simple lighting setup.

Optional (later):
- A minimal “session history” view that:
  - Calls Supabase from a server component or server action.
  - Lists the last N sessions (title + created_at).
  - Allows re-loading a session by its id (no regeneration required).


====================================================
BACKEND ARCHITECTURE (NEXT.JS API ON VERCEL)
====================================================

Implement the pipeline in a single API route:

- File: /app/api/generate-ip/route.ts (App Router)
- Method: POST

Pseudo-flow:

1. Parse JSON body: { idea: string }.
2. Input validation; if empty, use a fallback example idea.
3. Call OpenAI GPT (chat.completions or responses) to generate `config.json`.
   - Use a robust system/user prompt that:
     - Describes the desired schema for story config.
     - Enforces “JSON only” output.
4. Parse the GPT JSON result.
5. Call OpenAI Image API (DALL·E) to generate:
   - 3 comic panel images from `panels[i].image_prompt`.
   - 1 character reference image from `character_ref_prompt`.
6. Call Meshy.ai with the character reference image to generate a 3D model.
   - Handle asynchronous job polling if necessary.
   - Obtain a model URL (GLB/OBJ).
7. Call OpenAI GPT again to generate `game_config.json`, with:
   - The original idea.
   - The main_character section of `config.json`.
   - A description of the “3D Board Dash” isometric game and JSON schema.
   - Enforce strict JSON output as before.
8. Parse and sanitize the game config JSON.
9. Insert a new row into Supabase `ip_sessions` table (see schema below).
10. Respond to the frontend with a JSON payload:

   {
     "session_id": "<uuid-or-id>",
     "storyConfig": { ... },       // config.json (or subset)
     "gameConfig": { ... },        // game_config.json
     "comicPanels": [
       { "url": "https://..." },
       { "url": "https://..." },
       { "url": "https://..." }
     ],
     "characterRefImage": { "url": "https://..." },
     "model3D": {
       "url": "https://...",      // GLB or OBJ from Meshy
       "format": "glb"            // or "obj"
     }
   }

Notes:
- For Vercel, avoid reliance on permanent local file writes for serving assets.
- Ideally:
  - Use remote URLs returned directly by OpenAI and Meshy.
  - Or upload generated assets to a storage bucket (e.g., Vercel Blob Storage, Supabase Storage, S3) and return public URLs.
- For the MVP, it is acceptable to:
  - Use the URLs from the remote generation services directly in the frontend, if allowed by their CORS policies.


====================================================
SUPABASE INTEGRATION – MINIMAL DATABASE SUPPORT
====================================================

Goal:
- Minimal persistence for:
  - Logging generations (“sessions”).
  - Potentially revisiting a session later.

Environment Variables:
- SUPABASE_URL
- SUPABASE_ANON_KEY (for client-side if needed)
- SUPABASE_SERVICE_ROLE_KEY (for secure server-side writes, if used; DO NOT expose to client)

MVP: Use server-side Supabase client in the API route with a key that allows inserts into the `ip_sessions` table, while keeping secrets on the server only.

Suggested Table: `ip_sessions`

Schema (Postgres / Supabase):

- id: uuid (primary key, default gen_random_uuid())
- created_at: timestamptz (default now())
- ip_idea: text
- story_title: text
- story_logline: text
- story_config: jsonb
- game_config: jsonb
- comic_panel_urls: jsonb   // array of strings
- model_3d_url: text
- character_name: text      // from main_character.name (optional)
- notes: text               // optional freeform field

Minimal Server-side Operations:
- On successful generation:
  - Insert one row with:
    - ip_idea = user’s idea
    - story_title, story_logline from storyConfig
    - story_config = full config.json
    - game_config = full game_config.json
    - comic_panel_urls = array of generated image URLs
    - model_3d_url = URL to the GLB/OBJ
    - character_name = main_character.name
- Return `id` (as session_id) to the client.

Optional Future Enhancements (not required now):
- Add an endpoint `/api/session/:id` to fetch a prior session from Supabase and re-render without regenerating.
- Add an endpoint `/api/sessions` to list recent sessions.

Implementation Notes:
- Create a `supabaseServer.ts` helper using `@supabase/supabase-js` configured with SUPABASE_URL and a server-side key (service role or restricted key).
- All Supabase queries should be executed in server environment only (API routes or server components).
- Avoid exposing keys that can write to the database directly to the browser.


====================================================
INFRASTRUCTURE & VERCEL SETUP
====================================================

1. Project Setup
- Create a new Next.js (TypeScript) project suitable for Vercel deployment.
- Use `create-next-app` with the App Router if possible.
- Ensure `three`, `@types/three`, and any necessary loaders (GLTFLoader, OBJLoader) are installed.
- Install Supabase client: `@supabase/supabase-js`.

2. Environment Variables
The project will require environment variables for:
- OPENAI_API_KEY
- MESHY_API_KEY (or whatever name Meshy’s client expects)
- SUPABASE_URL
- SUPABASE_ANON_KEY (if you ever use client-side Supabase; optional for MVP)
- SUPABASE_SERVICE_ROLE_KEY or a restricted service key (for server-side inserts into `ip_sessions`)

On Vercel:
- Go to Project Settings → Environment Variables.
- Add these keys for Production (and optionally Preview/Development).
- In code, access via `process.env.OPENAI_API_KEY`, `process.env.SUPABASE_URL`, etc.

3. API Routes Runtime
- Use Node.js runtime (not Edge) if you need:
  - Larger memory for model calls.
  - Node-specific libraries (like OpenAI’s official SDKs and Supabase).
- In Next.js App Router, you can specify:

  export const runtime = "nodejs";

  in `/app/api/generate-ip/route.ts` if needed.

4. three.js on Vercel
- three.js runs entirely on the client side.
- Avoid SSR for the three.js canvas:
  - Use dynamic import with `ssr: false` if necessary.
  - Or only access `window` inside `useEffect` to prevent issues with server rendering.

5. Supabase on Vercel
- All writes to Supabase should be done server-side in the API route using the server-side Supabase client.
- Do not expose service role key to the client.
- For the MVP, you don’t need client-side Supabase at all; only server-side logging is required.

6. Build & Deploy
- Ensure `next.config.js` is valid; typically you don’t need special changes for this.
- Deploy to Vercel by:
  - Connecting the GitHub repo to Vercel, OR
  - Using `vercel` CLI.
- After deploying:
  - Confirm environment variables are set.
  - Test the flow:
    - Open app → input idea → click “Create 360 IP” → eventually see comic, game, and toy, and confirm a row is inserted into Supabase.

7. Rate, Time, and Cost Considerations
- Each generation run calls:
  - GPT at least twice (story config + game config).
  - DALL·E multiple times (comic panels + character ref).
  - Meshy once (image-to-3D).
- Consider:
  - Minimal prompt sizes.
  - Minimal image resolution that still looks good (e.g., 512–1024 px).
  - Having robust error handling and fallback messages if any step fails.


====================================================
WHAT YOU (GPT INSIDE CURSOR) SHOULD DO
====================================================

Given all of the above, you should:

1. Design the precise TypeScript interfaces for:
   - StoryConfig (config.json).
   - GameConfig (game_config.json).
   - API response payload.
   - Supabase session row shape (`IpSession` type).

2. Implement the Next.js frontend:
   - Input screen with UA logo, textarea, button, and loading state.
   - IP Ecosystem screen with:
     - EntertainmentPanel (comic).
     - GamePanel (three.js 3D Board Dash).
     - ToyPanel (3D model viewer with OrbitControls).

3. Implement three.js game logic:
   - Use angled camera looking down at the board.
   - Click-to-move character using raycasting.
   - Straight line movement with rotation toward target direction.
   - Prize/hazard spawning and collision detection.
   - Score and end-of-session logic.

4. Implement three.js toy viewer:
   - Load the same 3D character model (GLB/OBJ).
   - Add lights and OrbitControls.
   - Allow free rotation and zoom.

5. Implement `/api/generate-ip`:
   - Call GPT to get story config JSON.
   - Call DALL·E to generate images.
   - Call Meshy to get a 3D model.
   - Call GPT to get game config JSON.
   - Insert a session row into Supabase.
   - Return combined result to the frontend.

6. Implement Supabase helper and schema:
   - Provide SQL or migration for creating `ip_sessions` table.
   - Implement a `supabaseServer` helper for server-side writes.
   - Ensure writes are robust but minimal (no over-engineering).

7. Write robust prompts for GPT:
   - Separate prompts for:
     - Story & comic config.
     - Game config JSON.
   - Enforce JSON-only responses.
   - Include schema examples and constraints in the prompts.

8. Make everything ready to deploy on Vercel:
   - Ensure env var references are correct.
   - Use server runtime for API calls where needed.
   - Avoid filesystem assumptions that don’t hold on serverless.

9. Keep the implementation minimal and MVP-oriented:
   - Only one game template: 3D Board Dash with angled camera.
   - Only one toy model viewer style.
   - Only a 3-panel comic layout.
   - Only one database table (`ip_sessions`) with minimal fields.
   - Simple, clean CSS with responsive layout if possible, but no over-engineering.

You may now begin proposing file structures, types, prompts, Supabase schema, and code for this project consistent with the above specification.

